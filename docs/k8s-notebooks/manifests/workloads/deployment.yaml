apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  annotations:
    meta.helm.sh/release-name: web1
    meta.helm.sh/release-namespace: app1
  name: example
  labels: 
    app: example
  namespace: app1
spec:
  minReadySeconds: 20  #Deployment 会根据 Pod ready 来看 Pod 是否可用，但是如果我们设置了 MinReadySeconds 之后，比如设置为 30 秒，那 Deployment 就一定会等到 Pod ready 超过 30 秒之后才认为 Pod 是 available 的。Pod available 的前提条件是 Pod ready，但是 ready 的 Pod 不一定是 available 的，它一定要超过 MinReadySeconds 之后，才会判断为 available；
  progressDeadlineSeconds: 300   #当 Deployment 处于扩容或者发布状态时，它的 condition 会处于一个 processing 的状态，processing 可以设置一个超时时间。如果超过超时时间还处于 processing，那么 controller 将认为这个 Pod 会进入 failed 的状态。
  revisionHistoryLimit: 5  #保留历史 revision，即保留历史 ReplicaSet 的数量，默认值为 10 个。这里可以设置为一个或两个，如果回滚可能性比较大的话，可以设置数量超过 10；
  paused: False # paused 是标识，Deployment 只做数量维持，不做新的发布，在 Debug 场景可能会用到
  strategy:
    rollingUpdate:
      maxSurge: 25%  # 滚动过程中最多存在多少个 Pod 超过预期 replicas 数量。
      maxUnavailable: 25% # 滚动过程中最多有多少个 Pod 不可用
    type: RollingUpdate  # Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate
  selector:
    matchLabels:
      app: example
  replicas: 1 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: example
    spec:
      hostAliases:
        - hostnames:
            - www.dachui.com
          ip: 172.16.133.155
      tolerations:
      - key: node-role.kubernetes.io/master
        operator: Exists
        value: v1      #当op=Exists可为空
        effect: NoSchedule  #可以为空，匹配所有
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: kubernetes.io/hostname
                    operator: In
                    values:
                      - node
                      - node2
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - example
                topologyKey: kubernetes.io/hostname
              weight: 100
      nodeSelector:
        k1: v1
      initContainers:
      - image: mwendler/wget
        imagePullPolicy: IfNotPresent
        command:
          - wget
          -
          - -qO
          - /tmp/1.jpg
        name: initwork1
        volumeMounts:
        - name: hostpath1
          mountPath: /tmp
      containers:
      - name: filebeat
        image: registry-vpc.cn-shanghai.aliyuncs.com/pro1/ng1:v4_8080
        imagePullPolicy: IfNotPresent
        resources: 
          limits: 
            cpu: 100m
            memory: 250Mi
        volumeMounts:
        - name: emptydir1
          mountPath: /root/logs
          subPath: cache1  #在容器内建立子目录
          readOnly: true   #只读挂载
      - name: nginx
        image: registry.cn-shanghai.aliyuncs.com/baiyuani/web1:0.0.4
        imagePullPolicy: IfNotPresent   # choose for: IfNotPresent , Always , Never
        command:
          - sh
          - -c
          - sleep 3600
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: TZ
          value: Asia/Shanghai
        - name: JAVA_TOOL_OPTIONS
          value: "-Xmx1600m -Xms800m"
        - name: TZ
          valueFrom:
            configMapKeyRef:
              name: nginx-conf
              key: ZONE
        - name: TZ
          valueFrom:
            secretKeyRef:
              name: example-secret
              key: ZONE
        envFrom:
        - secretRef:
            name: example-secret
            optional: true
        - configMapRef:
            name: example-cm
            optional: true
        resources:
          requests:
            ephemeral-storage: "2Gi"
            cpu: 100m
            memory: 128Mi
          limits: 
            ephemeral-storage: "4Gi"
            cpu: 250m
            memory: 256Mi
        ports:
        - containerPort: 80
          protocol: TCP
          name: http
        lifecycle:
          postStart:
            exec:
              command:
                - /bin/sh
                - -c
                - ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
                # - echo "start - $(date)" >> /var/log/nginx/start.log
          preStop:
            exec:
              command:
                - /bin/sh
                - -c
                - sleep 10
        livenessProbe: 
          failureThreshold: 3
          initialDelaySeconds: 15
          periodSeconds: 10
          successThreshold: 1
          tcpSocket: 
            port: 80
          timeoutSeconds: 3
        readinessProbe: 
          failureThreshold: 3
          initialDelaySeconds: 15
          periodSeconds: 10
          successThreshold: 1
          httpGet:
            path: /readyz
            port: http
            httpHeaders:
            - name: Custom-Header
              value: Awesome            
          timeoutSeconds: 3
        startupProbe:
          failureThreshold: 3
          initialDelaySeconds: 15
          periodSeconds: 10
          successThreshold: 1
          exec:
            command:
            - cat
            - /tmp/healthy
          timeoutSeconds: 3
        securityContext:
          runAsUser: 1001
          runAsNonRoot: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: false
          privileged: true   #设置特权容器          
        volumeMounts:
        - mountPath: /usr/share/zoneinfo/Asia/Shanghai
          name: localtime
        - name: nfs-volume
          mountPath: /share        
        - name: nas-pvc
          mountPath: /usr/share/nginx/html
        - name: emptydir1
          mountPath: /var/log/init_log
        - name: hostpath1
          mountPath: /tmp/hostpath1
        - name: conf  # 这里使用的是volume的名字
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
        - name: conf
          mountPath: /etc/nginx/test.conf
          subPath: test.conf
        - name: loginfo
          mountPath: /root/loginfo.conf
          readOnly: True
        - mountPath: "/scratch"
          name: scratch-volume
      volumes:
      - name: nfs-volume
        nfs:
          server: my-nfs-server.example.com
          path: /my-nfs-volume
          readOnly: true      
      - hostPath:
          path: /usr/share/zoneinfo/Asia/Shanghai
          type: ""
        name: localtime
      - name: nas-pvc
        persistentVolumeClaim: 
          claimName: pvc-nfs1
      - name: emptydir1
        emptyDir: 
          medium: Memory  # 可以将 emptyDir.medium 字段设置为 "Memory"， 以告诉 Kubernetes 为你挂载 tmpfs（基于 RAM 的文件系统）。 虽然 tmpfs 速度非常快，但是要注意它与磁盘不同：tmpfs 在节点重启时会被清除， 并且你所写入的所有文件都会计入容器的内存消耗，受容器内存限制约束。
          sizeLimit: 128Mi
      - name: hostpath1
        hostPath:
          path: /tmp/data
      - configMap:
          defaultMode: 0664  # 配置权限
          name: nginx-conf   # 声明要挂载的cm
          items:  # cm中有多个配置文件需要挂载时使用
          - key: nginx.conf
            path: nginx.conf  #  相当于给key起别名，在mountVolume使用
          - key: test_conf
            path: test.conf
        name: conf  # 声明volume的名字
      - secret:
          secretName: pass
          defaultMode: 0664
        name: loginfo
      - name: scratch-volume
        # 通用临时卷 Kubernetes v1.23 [stable]
        ephemeral:
          volumeClaimTemplate:
            metadata:
              labels:
                type: my-frontend-volume
            spec:
              accessModes: [ "ReadWriteOnce" ]
              storageClassName: "scratch-storage-class"
              resources:
                requests:
                  storage: 1Gi
      imagePullSecrets:   #  使用云平台上的镜像仓库时，不需要配置此项，默认pod使用的serviceAccount包含了该配置
        - name: docker-registry
      restartPolicy: Always
      priorityClassName: system-cluster-critical
      schedulerName: default-scheduler
      securityContext:
        fsGroup: 1001
        runAsNonRoot: true
        runAsUser: 1001
      terminationGracePeriodSeconds: 60  # Max waiting time before container exit
      #如果为 ClusterFirst 和 ClusterFirstWithHostNet 都使用 coredns server 地址 ;
      #如果为 Default, 则使用 pod 所在的宿主机的配置 ;
      #如果为 None, 则使用 pod spec 中的 dnsConfig 配置.
      dnsPolicy: ClusterFirst
