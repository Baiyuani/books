
### Pod 的配置管理



![img](https://edu.aliyun.com/files/course/2021/04-02/170223f594d6059219.png)



### ConfigMap

![img](https://edu.aliyun.com/files/course/2021/04-02/170337956066849266.png)



指定文件话，文件名就是 Map 中的 key，文件内容就是 Map 中的 value。

指定键值对就是指定数据键值对，即：key:value 形式，直接映射到 Map 的key:value。



![img](https://edu.aliyun.com/files/course/2021/04-02/170411bacf54671201.png)

- 第一种是环境变量。环境变量的话通过 valueFrom，然后 ConfigMapKeyRef 这个字段，下面的 name 是指定 ConfigMap 名，key 是 ConfigMap.data 里面的 key。这样的话，在 busybox 容器启动后容器中执行 env 将看到一个 SPECIAL_LEVEL_KEY 环境变量；
- 第二个是命令行参数。命令行参数其实是第一行的环境变量直接拿到 cmd 这个字段里面来用；
- 最后一个是通过 volume 挂载的方式直接挂到容器的某一个目录下面去。上面的例子是把 special-config 这个 ConfigMap 里面的内容挂到容器里面的 /etc/config 目录下，这个也是使用的一种方式。



configmap注意点：

1. ConfigMap 文件的大小。虽然说 ConfigMap 文件没有大小限制，但是在 ETCD 里面，数据的写入是有大小限制的，现在是限制在 1MB 以内；
2. 第二个注意点是 pod 引入 ConfigMap 的时候，必须是相同的 Namespace 中的 ConfigMap，前面其实可以看到，ConfigMap.metadata 里面是有 namespace 字段的；
3. 第三个是 pod 引用的 ConfigMap。假如这个 ConfigMap 不存在，那么这个 pod 是无法创建成功的，其实这也表示在创建 pod 前，必须先把要引用的 ConfigMap 创建好；
4. 第四点就是使用 envFrom 的方式。把 ConfigMap 里面所有的信息导入成环境变量时，如果 ConfigMap 里有些 key 是无效的，比如 key 的名字里面带有数字，那么这个环境变量其实是不会注入容器的，它会被忽略。但是这个 pod 本身是可以创建的。这个和第三点是不一样的方式，是 ConfigMap 文件存在基础上，整体导入成环境变量的一种形式；
5. 最后一点是：什么样的 pod 才能使用 ConfigMap？这里只有通过 K8s api 创建的 pod 才能使用 ConfigMap，比如说通过用命令行 kubectl 来创建的 pod，肯定是可以使用 ConfigMap 的，但其他方式创建的 pod，比如说 kubelet 通过 manifest 创建的 static pod，它是不能使用 ConfigMap 的。



### Secret

Secret 是一个主要用来存储密码 token 等一些敏感信息的资源对象。其中，敏感信息是采用 base-64 编码保存起来的



Secret 类型种类比较多，下面列了常用的四种类型：

- 第一种是 Opaque，它是普通的 Secret 文件；
- 第二种是 service-account-token，是用于 service-account 身份认证用的 Secret；
- 第三种是 dockerconfigjson，这是拉取私有仓库镜像的用的一种 Secret；
- 第四种是 bootstrap.token，是用于节点接入集群校验用的 Secret。

![img](https://edu.aliyun.com/files/course/2021/04-02/1705051ec10b317668.png)

![img](https://edu.aliyun.com/files/course/2021/04-02/1705382104ff566835.png)

![img](https://edu.aliyun.com/files/course/2021/04-02/170606e21066114511.png)

Secret使用注意点：

1. 第一个是 Secret 的文件大小限制。这个跟 ConfigMap 一样，也是 1MB；

 

2. 第二个是 Secret 采用了 base-64 编码，但是它跟明文也没有太大区别。所以说，如果有一些机密信息要用 Secret 来存储的话，还是要很慎重考虑。也就是说谁会来访问你这个集群，谁会来用你这个 Secret，还是要慎重考虑，因为它如果能够访问这个集群，就能拿到这个 Secret。

 

如果是对 Secret 敏感信息要求很高，对加密这块有很强的需求，推荐可以使用 Kubernetes 和开源的 vault做一个解决方案，来解决敏感信息的加密和权限管理。

 

3. 第三个就是 Secret 读取的最佳实践，建议不要用 list/watch，如果用 list/watch 操作的话，会把 namespace 下的所有 Secret 全部拉取下来，这样其实暴露了更多的信息。推荐使用 GET 的方法，这样只获取你自己需要的那个 Secret。



### SeviceAccount

ServiceAccount 首先是用于解决 pod 在集群里面的身份认证问题，身份认证信息是存在于 Secret 里面。(kubernetes.io/service-account-token)

![img](https://edu.aliyun.com/files/course/2021/04-02/17064229d3af867454.png)

##### 举例：Pod 里的应用访问它所属的 K8s 集群

 pod 创建的时候，首先它会把这个 secret 挂载到容器固定的目录下，pod 要访问集群的时候，首先进行身份认证

![img](https://edu.aliyun.com/files/course/2021/04-02/17071205a518475315.png)

认证完之后 pod 的身份信息会有两部分：一个是 Group，一个是 User。身份认证是就是认证这两部分信息。接着可以使用 RBAC 功能，对 pod 进行一个授权管理。

假如 RBAC 没有配置的话，默认的 pod 具有资源 GET 权限，就是可以从所属的 K8s 集群里 get 数据。如果是需要更多的权限，那么就需要 自行配置 RBAC 。



### Resource

目前内部支持类型有三种：CPU、内存，以及临时存储。当用户觉得这三种不够，有自己的一些资源，比如说 GPU，或者其他资源，也可以自己来定义，但配置时，指定的数量必须为整数。目前资源配置主要分成 request 和 limit 两种类型，一个是需要的数量，一个是资源的界限。CPU、内存以及临时存储都是在 container 下的 Resource 字段里进行一个声明。

![img](https://edu.aliyun.com/files/course/2021/04-02/170741dc78be254697.png)



Pod 服务质量 (QoS) 配置:

根据 CPU 对容器内存资源的需求，对 pod 的服务质量进行一个分类，分别是 Guaranteed、Burstable 和 BestEffort。



- Guaranteed ：pod 里面每个容器都必须有内存和 CPU 的 request 以及 limit 的一个声明，且 request 和 limit 必须是一样的，这就是 Guaranteed；
- Burstable：Burstable 至少有一个容器存在内存和 CPU 的一个 request；
- BestEffort：只要不是 Guaranteed 和 Burstable，那就是 BestEffort。

 

资源配置好后，当这个节点上 pod 容器运行，比如说节点上 memory 配额资源不足，kubelet会把一些低优先级的，或者说服务质量要求不高的（如：BestEffort、Burstable）pod 驱逐掉。它们是按照先去除 BestEffort，再去除 Burstable 的一个顺序来驱逐 pod 的。



### SecurityContext

SecurityContext 主要是用于限制容器的一个行为，它能保证系统和其他容器的安全。这一块的能力不是 Kubernetes 或者容器 runtime 本身的能力，而是 Kubernetes 和 runtime 通过用户的配置，最后下传到内核里，再通过内核的机制让 SecurityContext 来生效。

 

SecurityContext 主要分为三个级别：

- 第一个是容器级别，仅对容器生效；
- 第二个是 pod 级别，对 pod 里所有容器生效；
- 第三个是集群级别，就是 PSP，对集群内所有 pod 生效。

 

权限和访问控制设置项，现在一共列有七项（这个数量后续可能会变化）：

 

1. 第一个就是通过用户 ID 和组 ID 来控制文件访问权限；
2. 第二个是 SELinux，它是通过策略配置来控制用户或者进程对文件的访问控制；
3. 第三个是特权容器；
4. 第四个是 Capabilities，它也是给特定进程来配置一个 privileged 能力；
5. 第五个是 AppArmor，它也是通过一些配置文件来控制可执行文件的一个访问控制权限，比如说一些端口的读写；
6. 第六个是一个对系统调用的控制；
7. 第七个是对子进程能否获取比父进程更多的权限的一个限制。

 

最后其实都是落到内核来控制它的一些权限。

![img](https://edu.aliyun.com/files/course/2021/04-02/170810abc0a1697313.png)



### InitContainer

 InitContainer 和普通 container 的区别，有以下三点内容：

 

1. InitContainer 首先会比普通 container 先启动，并且直到所有的 InitContainer 执行成功后，普通 container 才会被启动；
2. InitContainer 之间是按定义的次序去启动执行的，执行成功一个之后再执行第二个，而普通的 container 是并发启动的；
3. InitContainer 执行成功后就结束退出，而普通容器可能会一直在执行。它可能是一个 longtime 的，或者说失败了会重启，这个也是 InitContainer 和普通 container 不同的地方。
