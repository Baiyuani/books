### 资源元信息

1. Kubernetes 资源对象

   Kubernetes 的资源对象组成：主要包括了 Spec、Status 两部分。其中 Spec 部分用来描述期望的状态，Status 部分用来描述观测到的状态。

2. 元数据部分。

   该部分主要包括了用来识别资源的标签：Labels， 用来描述资源的注解；Annotations， 用来描述多个资源之间相互关系的 OwnerReference。

   - labels 资源标签

     标签主要用来筛选资源和组合资源，可以使用类似于 SQL 查询 select，来根据 Label 查询相关的资源。

   - Selector 

     matchLabels用于定义一组Label，与直接写在Selector中作用相同：matchExpression用于定义一组基于集合的筛选条件，可用的条件运算符包括：In、NotIn、Exists和DoesNotExist。

     ```yaml
     spec: 
       selector:
         matchLabels:
           app: myweb
         matchExpressions:
           - {key: tier, operator: In, values: [frontend]}
           - {key: environment, operator: NotIn, values: [dev]}
     ```
   
   - Annotations
   
     一般是系统或者工具用来存储资源的非标示性信息，可以用来扩展资源的 spec/status 的描述
   
     ![img](https://edu.aliyun.com/files/course/2021/04-02/155853da47a1017126.png)
   
   - Ownereference
   
     一般就是指集合类的资源，比如说 Pod 集合，就有 replicaset、statefulset

### 操作

1. labels

kubectl get pod --show-labels    #获取pod列表并显示labels

kubectl label pod POD KEY=VALUE	#为pod设置label

kubectl label pod POD KEY=VALUE --overwrite	#覆盖已配置的label

kubectl label pod POD KEY-	#删除label

kubectl get pod --show-labels -l KEY=VALUE	#过滤出匹配该label的pod

kubectl get pod --show-labels -l K1=V1,K2=V2	#多条件过滤，条件间为且的关系

kubectl get pod --show-labels -l ‘K in (V1,V2)’	#多条件过滤，条件间为或的关系

2. annotations

kubectl annotate pod POD KEY=‘VALUES’	#配置annotation

![img](https://edu.aliyun.com/files/course/2021/04-02/155853da47a1017126.png)

3. OwnerReferences

   通过replicaset，deployment等对象创建出来的pod会带有OwnerReferences

   ![image-20210602150552328](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20210602150552328.png)

   

### 控制器模式

1. 控制循环

控制型模式最核心的就是控制循环的概念。在控制循环中包括了控制器，被控制的系统，以及能够观测系统的传感器，三个逻辑组件。

 

当然这些组件都是逻辑的，外界通过修改资源 spec 来控制资源，控制器比较资源 spec 和 status，从而计算一个 diff，diff 最后会用来决定执行对系统进行什么样的控制操作，控制操作会使得系统产生新的输出，并被传感器以资源 status 形式上报，控制器的各个组件将都会是独立自主地运行，不断使系统向 spec 表示终态趋近。

![160220cc4626661070](C:\Users\Hanabi\Desktop\云原生\.doc\160220cc4626661070.png)



2、Sensor

控制循环中逻辑的传感器主要由 Reflector、Informer、Indexer 三个组件构成。

 

Reflector 通过 List 和 Watch K8s server 来获取资源的数据。List 用来在 Controller 重启以及 Watch 中断的情况下，进行系统资源的全量更新；而 Watch 则在多次 List 之间进行增量的资源更新；Reflector 在获取新的资源数据后，会在 Delta 队列中塞入一个包括资源对象信息本身以及资源对象事件类型的 Delta 记录，Delta 队列中可以保证同一个对象在队列中仅有一条记录，从而避免 Reflector 重新 List 和 Watch 的时候产生重复的记录。

 

Informer 组件不断地从 Delta 队列中弹出 delta 记录，然后把资源对象交给 indexer，让 indexer 把资源记录在一个缓存中，缓存在默认设置下是用资源的命名空间来做索引的，并且可以被 Controller Manager 或多个 Controller 所共享。之后，再把这个事件交给事件的回调函数

![img](https://edu.aliyun.com/files/course/2021/04-02/160252c32afc142089.png)

控制循环中的控制器组件主要由事件处理函数以及 worker 组成，事件处理函数之间会相互关注资源的新增、更新、删除的事件，并根据控制器的逻辑去决定是否需要处理。对需要处理的事件，会把事件关联资源的命名空间以及名字塞入一个工作队列中，并且由后续的 worker 池中的一个 Worker 来处理，工作队列会对存储的对象进行去重，从而避免多个 Woker 处理同一个资源的情况。

 

Worker 在处理资源对象时，一般需要用资源的名字来重新获得最新的资源数据，用来创建或者更新资源对象，或者调用其他的外部服务，Worker 如果处理失败的时候，一般情况下会把资源的名字重新加入到工作队列中，从而方便之后进行重试。



3. 控制循环例子-扩容

这里举一个简单的例子来说明一下控制循环的工作原理。

 

ReplicaSet 是一个用来描述无状态应用的扩缩容行为的资源， ReplicaSet controler 通过监听 ReplicaSet 资源来维持应用希望的状态数量，ReplicaSet 中通过 selector 来匹配所关联的 Pod，在这里考虑 ReplicaSet rsA 的，replicas 从 2 被改到 3 的场景。

![img](https://edu.aliyun.com/files/course/2021/04-02/160326e52951651124.png)

首先，Reflector 会 watch 到 ReplicaSet 和 Pod 两种资源的变化，为什么我们还会 watch pod 资源的变化稍后会讲到。发现 ReplicaSet 发生变化后，在 delta 队列中塞入了对象是 rsA，而且类型是更新的记录。

 

Informer 一方面把新的 ReplicaSet 更新到缓存中，并与 Namespace nsA 作为索引。另外一方面，调用 Update 的回调函数，ReplicaSet 控制器发现 ReplicaSet 发生变化后会把字符串的 nsA/rsA 字符串塞入到工作队列中，工作队列后的一个 Worker 从工作队列中取到了 nsA/rsA 这个字符串的 key，并且从缓存中取到了最新的 ReplicaSet 数据。

 

Worker 通过比较 ReplicaSet 中 spec 和 status 里的数值，发现需要对这个 ReplicaSet 进行扩容，因此 ReplicaSet 的 Worker 创建了一个 Pod，这个 pod 中的 Ownereference 取向了 ReplicaSet rsA。

 

 

然后 Reflector Watch 到的 Pod 新增事件，在 delta 队列中额外加入了 Add 类型的 deta 记录，一方面把新的 Pod 记录通过 Indexer 存储到了缓存中，另一方面调用了 ReplicaSet 控制器的 Add 回调函数，Add 回调函数通过检查 pod ownerReferences 找到了对应的 ReplicaSet，并把包括 ReplicaSet 命名空间和字符串塞入到了工作队列中。

![img](https://edu.aliyun.com/files/course/2021/04-02/1604182d5962398236.png)

ReplicaSet 的 Woker 在得到新的工作项之后，从缓存中取到了新的 ReplicaSet 记录，并得到了其所有创建的 Pod，因为 ReplicaSet 的状态不是最新的，也就是所有创建 Pod 的数量不是最新的。因此在此时 ReplicaSet 更新 status 使得 spec 和 status 达成一致。



### 控制器模式总结

Kubernetes 控制器模式依赖声明式的 API。(与之相对的是命令式API)
